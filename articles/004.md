# 学习笔记：多线程1

_Anthony Williams_ 的 _C++ Concurrency In Action_ 到货了。在正式开始研究之前，先总结一
下长久以来对于多线程使用的疑虑。希望能在书中找到答案。

虽然现在才开始看多线程相关的书籍，但是实际上已经用过很多次多线程相关的东西。在以往的使用中，有几
件事总是阴魂不散地总是难以解决。大致如下：

1. 如何确定该启动多少线程
2. 线程竞争的资源该如何配置，确保线程有效率地运作
3. 如何复用已有线程，而不是启动新线程
4. 在需要大量的异步操作时，如何确保不因为过多的"锁"导致效率降低
5. 如何在线程之间安全地传递资源
6. 如何监测和管理线程状态（如自动杀死挂掉的线程，启动新线程）
7. 如何让单个线程的崩溃／异常不影响整个进程
8. 如何进行错误处理
9. ......

下面是在以前的多线程实践中，我总结出来的一些设想。留存此处作为备忘，供读书以后对比参考。

## 线程复用

不仅仅是线程。提起资源复用，大概有两种形式：队列、池。<br>此处，我们将这一方法抽象为：
**线程（thread）** 通过执行一系列 **任务（task）** 来完成工作。 而不是使用底层抽象：线程通过
 **入口函数** 来完成工作。<br>这里人为地将队列和线程池割裂开来，是为了方便总结不同设计的优势与
 劣势。实际使用是应该发挥C++的 优势，将好用的工具结合起来用。

### 队列

顾名思义，作为一个队列，将线程要执行的操作排入一个队列中，依次执行。队列操作的优势：

- 很容易获得队列长度，从而对多个线程资源进行调度
- 容易实现，逻辑简单
- ....

然而也具有一些缺陷：

- 如果实现使用"每个进程一个队列"的形式，则无法确定某一任务的等待时间。但这样可以保证队列中任务
- 的执行次序是 **顺序的**。
- 如果使用"多个线程共用一个队列"，就可以避免某个队列中的某些任务等待时间过长，也可以很方便的检
- 测整个复用部分的压力。但是这样做可能会导致 **同步问题**，因为队列中的任务执行次序不是顺序的。
- 也会对容器产生额外的要求，增加同步操作的难度。各种复杂的操作几乎难以保证是 **原子** 的，因而
- 必须使用锁。
- 如果需要改变线程数量。尤其是如果需要增加大量的工作线程，则可能会导致资源竞争加剧，效率降低。
- ....
- -

### 线程池

优势：

- 对于每一个将要执行的 **任务** ，线程池可以保证这个任务将会 **尽快被执行**， 从而保证对于
- 每个任务的等待时间都是最短的。
- 在一定程度上可以肆无忌惮地扩充线程池池的规模，不需要担心资源竞争的问题。（但这也可能会导致维护
线程状态的开销加剧，取决于具体实现。我觉得这里应该提供多个不同的实现，以满足不同的性能需求）

劣势：

- 需要维护线程的状态。线程实现必须支持能够判断当前线程是 **忙碌** 还是 **空闲**.
- 对于一个“池”来说，一般拥有 __获取对象__ 和 __释放对象__ 的操作。对于线程池而言，
__获取对象__ ___可能___ 意味着新任务被执行。对于 __线程__ 这种对象来说，当池中对象被释放时，
___可能___ 意味着线程在忙碌，也可能任务已完成，线程已经空闲。为了检测这些状态，同时对用户保持
状态管理的隐藏和透明，必须在 __线程内部__ 运行一个管理函数。私以为有两种实现方法：
  1. 在线程的实现中为池操作提供私有接口，或者干脆让线程类型本身具备状态管理的能力。由于C++模板
  的存在，可以方便地通过模板参数生成不同默认行为的类型（STL中的关联容器是一个很好的例子）。
  2. 线程池提供一组特有的操作。要么提供一个特殊版本的线程类型，要么提供一套特殊版本的控制方法。
  总之进行一次封装。这一封装如果要做的完全透明，非常有挑战性，也很没有价值。然而在某些COM项目中
  却常见这种做法。由于无法把封装做的完美，所以框架会选择让用户学会使用特别定制的类型。从而衍生
  出一系列“开发者用着爽，用户用着不爽”的东西。我个人非常不喜欢这种缚手缚脚的行为。__不自由__
  有悖于C++的理念。
