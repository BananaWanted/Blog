# 学习笔记：多线程1
_Anthony Williams_ 的 _C++ Concurrency In Action_ 到货了。在正式开始研究之前，先总结一下
长久以来对于多线程使用的疑虑。希望能在书中找到答案。

虽然现在才开始看多线程相关的书籍，但是实际上已经用过很多次多线程相关的东西。在以往的使用中，有几件事
总是阴魂不散地总是难以解决。大致如下：

1. 如何确定该启动多少线程
2. 线程竞争的资源该如何配置，确保线程有效率地运作
3. 如何复用已有线程，而不是启动新线程
4. 在需要大量的异步操作时，如何确保不因为过多的“锁”导致效率降低
5. 如何在线程之间安全地传递资源
6. 如何监测和管理线程状态（如自动杀死挂掉的线程，启动新线程）
7. 如何让单个线程的崩溃／异常不影响整个进程
8. 如何进行错误处理
9. ......

下面是在以前的多线程实践中，我总结出来的一些设想。留存此处作为备忘，供读书以后对比参考。

## 线程复用
不仅仅是线程。提起资源复用，大概有两种形式：队列、池。  
此处，我们将这一方法抽象为： __线程（thread）__ 通过执行一系列 __任务（task）__ 来完成工作。而不是
使用底层抽象：线程通过 __入口函数__ 来完成工作。  
这里人为地将队列和线程池割裂开来，是为了方便总结不同设计的优势与劣势。实际使用是应该发挥C++的优势，
将好用的工具结合起来用。

### 队列
顾名思义，作为一个队列，将线程要执行的操作排入一个队列中，依次执行。队列操作的优势：

- 很容易获得队列长度，从而对多个线程资源进行调度
- 容易实现，逻辑简单
- ....

然而也具有一些缺陷：

- 如果实现使用“每个进程一个队列”的形式，则无法确定某一任务的等待时间。但这样可以保证队列中任务
的执行次序是 __顺序的__。
- 如果使用“多个线程共用一个队列“，就可以避免某个队列中的某些任务等待时间过长，也可以很方便的检
测整个复用部分的压力。但是这样做可能会导致 __同步问题__，因为队列中的任务执行次序不是顺序的。
- 也会对容器产生额外的要求，增加同步操作的难度。各种复杂的操作几乎难以保证是 __原子__ 的，因而
必须使用锁。
- ....
-

### 线程池
